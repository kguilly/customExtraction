/*
This file will test if its possible to send a file pointer to CUDA and then extract the GRIB 2 file using 
an object generated by ECCODES that will indicate where to find the values 


*/



#include <iostream>
#include <stdlib.h>
#include "eccodes.h"
#include <cuda_runtime.h>
#include <vector>
#include <string>

#define MAX_NUM_STRINGS 100
#define MAX_STRING_LENGTH 100
#define numParams 3


const char * grib_file_path = "/media/kaleb/extraSpace/wrf/";
const char * output_file_path = "/home/kaleb/Desktop/cuda_4-3/";
std::vector<std::string> vctrDate = {"2020", "01", "01"};
codes_index* index = NULL;
char shortnames[MAX_NUM_STRINGS][MAX_STRING_LENGTH]= {"2t", "u", "v"};
long passed_levels[numParams] = {2, 1000, 1000};
int param_indexes[numParams][numParams] = {{-1, -1, -1},
                                           {-1, -1, -1},
                                           {-1, -1, -1}}

typedef struct Station{
    float lat;
    float lon;
    double **values;
    int closestPoint;
} station_t;

station_t * stationArr;
int numStations;

station_t* extract_indexes(station_t *);
__global__ void cuda_find_nearest(station_t*, double*, double*, int, int);
void build_index_obj();


int main() {

    station_t st_1;
    station_t st_2;
    st_1.lat = 30.2241;
    st_1.lon = 272.0198;

    st_2.lat = 29.7958;
    st_2.lon = 270.8229;

    station_t* stationArr = new station_t[2];
    numStations = 2;
    stationArr[0] = st_1;
    stationArr[1] = st_2;

    std::cout << "BEFORE" << std::endl;
    for (int i=0; i<numStations; i++) {
        station_t st = stationArr[i];
        std::cout << "CL PT for st " << i << ": " << st.closestPoint << std::endl;
    }

    stationArr = extract_indexes(stationArr);
    std::cout << "\nAFTER" << std::endl;
    for (int i=0; i<numStations; i++) {
        station_t st = stationArr[i];
        std::cout << "CL PT for st " << i << ": " << st.closestPoint << std::endl;
    }

    // build the grib_index object
    build_index_obj();


    codes_index_delete(index);
    delete [] stationArr;

    return 0;
}

station_t* extract_indexes(station_t * local_st_arr){

    FILE* f;
    // std::string file_name = grib_file_path + vctrDate.at(0) + "/" + \
    //                     vctrDate.at(0) + vctrDate.at(1) + vctrDate.at(2)
    std::string full_file_name = "/media/kaleb/extraSpace/wrf/2020/20200101/hrrr.20200101.00.00.grib2";

    try {
        f = fopen(full_file_name.c_str(), "rb");
        if (!f) throw(full_file_name);
    }
    catch (std::string file) {
        std::cout << "could not open file: " << file << std::endl;
        return NULL;
    }

    long num_points =0;
    const double missing = 1.23456e36;
    codes_handle * h = NULL;
    int err = 0;
    double *grib_lats, *grib_lons, *grib_values;
    h = codes_handle_new_from_file(0, f, PRODUCT_GRIB, &err);
    if (!h || err != 0) {
        std::cout << "could not make handle" << std::endl;
        return NULL;
    }
    CODES_CHECK(codes_get_long(h, "numberOfPoints", &num_points), 0);
    CODES_CHECK(codes_set_double(h, "missingValue", missing), 0);

    grib_lats = (double*)malloc(num_points * sizeof(double));
    if(!grib_lats){
        fprintf(stderr, "Error: unable to allocate %ld bytes\n", (long)(num_points * sizeof(double)));
        exit(0);
    }
    grib_lons = (double*)malloc(num_points * sizeof(double));
    if (!grib_lons){
        fprintf(stderr, "Error: unable to allocate %ld bytes\n", (long)(num_points * sizeof(double)));
        std::free(grib_lats);
        exit(0);
    }
    grib_values = (double*)malloc(num_points * sizeof(double));
    if(!grib_values){
        fprintf(stderr, "Error: unable to allocate %ld bytes\n", (long)(num_points * sizeof(double)));
        std::free(grib_lats);
        std::free(grib_lons);
        exit(0);
    }
    CODES_CHECK(codes_grib_get_data(h, grib_lats, grib_lons, grib_values), 0);

    cudaSetDevice(0);
    int num_threads = 256;
    int num_blocks = 10;

    // std::cout << "we made it here" << std::endl;

    station_t* d_stationArr_np;
    double *d_lats, *d_lons;

    // allocate each of the arguments to the GPU
    if (cudaMalloc(&d_stationArr_np, sizeof(station_t) * numStations) != cudaSuccess) {
        std::cout << "stationArr could not be allocated to GPU" << std::endl;
        exit(0);
    }
    if (cudaMalloc(&d_lats, sizeof(double) * num_points) != cudaSuccess) {
        std::cout << "Grib lats could not be allocated to the GPU" << std::endl;
        cudaFree(d_stationArr_np);
        exit(0);
    }
    if (cudaMalloc(&d_lons, sizeof(double) * num_points) != cudaSuccess) {
        std::cout << "Grib lons could not be allocated to the GPU" << std::endl;
        cudaFree(d_stationArr_np);
        cudaFree(d_lats);
        exit(0);
    }

    // copy each of the arguments over to the gpu
    if (cudaMemcpy(d_stationArr_np, local_st_arr, sizeof(station_t) * numStations, cudaMemcpyHostToDevice) != cudaSuccess) {
        std::cout << "The stationArr could not be copied to the GPU" << std::endl;
        cudaFree(d_stationArr_np);
        cudaFree(d_lats);
        cudaFree(d_lons);
        exit(0);
    }
    if (cudaMemcpy(d_lats, grib_lats, sizeof(double) * num_points, cudaMemcpyHostToDevice) != cudaSuccess) {
        std::cout << "The grib lats could not be copied to the GPU" << std::endl;
        cudaFree(d_stationArr_np);
        cudaFree(d_lats);
        cudaFree(d_lons);
        exit(0);
    }
    if (cudaMemcpy(d_lons, grib_lons, sizeof(double) * num_points, cudaMemcpyHostToDevice) != cudaSuccess) {
        std::cout << "The grib lons could not be copied to the GPU" << std::endl;
        cudaFree(d_stationArr_np);
        cudaFree(d_lats);
        cudaFree(d_lons);
        exit(0);
    }
    
    // call the kernel
    cuda_find_nearest <<< num_blocks, num_threads >>> (d_stationArr_np, d_lats, d_lons, numStations, num_points);
    // wait for em all to finish
    cudaDeviceSynchronize();

    // copy the elements from the GPU back over to the host
    if (cudaMemcpy(local_st_arr, d_stationArr_np, sizeof(station_t) * numStations, cudaMemcpyDeviceToHost) != cudaSuccess) {
        std::cout << "cuda FAILED" << std::endl;
        cudaFree(d_stationArr_np);
        cudaFree(d_lats);
        cudaFree(d_lons);
        exit(0);
    }
    std::cout << "cuda success" << std::endl;
    // release
    cudaFree(d_stationArr_np);
    cudaFree(d_lats);
    cudaFree(d_lons);

    std::free(grib_lats);
    std::free(grib_lons);
    std::free(grib_values);

    return local_st_arr;
}

__global__ void cuda_find_nearest(station_t * d_stationArr, double * d_lats, double * d_lons, int numStations, int num_points) {
    int id = blockIdx.x * blockDim.x + threadIdx.x;

    if (id < numStations) {
        double min_distance = 999;
        int min_index = -1;
        
        station_t * curr_station = &d_stationArr[id];
        double st_lat = curr_station->lat;
        double st_lon = curr_station->lon;

        for (int i=0; i<num_points; i++) {
            double lat = d_lats[i];
            double lon = d_lons[i]; 
            double distance = sqrt(pow((st_lat - lat), 2) + pow((st_lon - lon), 2));

            if (distance < min_distance) {
                min_distance = distance;
                min_index = i;
            }
        }
        curr_station->closestPoint = min_index;
    }
}

void build_index_obj () {
    codes_handle* h    = NULL;
    const char* infile       = "/media/kaleb/extraSpace/wrf/2020/20200101/hrrr.20200101.00.00.grib2";
    long *steps, *levels, *numbers; /* arrays */
    char** shortName = NULL;
    int i, j, k, l;
    size_t stepSize, levelSize, shortNameSize, numberSize;
    long ostep, olevel, onumber;
    char oshortName[200];
    size_t lenshortName = 200;
    int ret = 0, count = 0;

    // if (argc != 2) usage(argv[0]);
    //infile = argv[1];

    printf("indexing...\n");

    /* create an index given set of keys*/
    index = codes_index_new(0, "shortName,level,step", &ret);
    if (ret) {
        fprintf(stderr, "Error: %s\n", codes_get_error_message(ret));
        exit(ret);
    }

    /* indexes a file */
    ret = codes_index_add_file(index, infile);
    if (ret) {
        fprintf(stderr, "Error: %s\n", codes_get_error_message(ret));
        exit(ret);
    }
    printf("end indexing...\n");

    /* get the number of distinct values of "step" in the index */
    CODES_CHECK(codes_index_get_size(index, "step", &stepSize), 0);
    steps = (long*)malloc(sizeof(long) * stepSize);
    if (!steps) exit(1);

    /* get the list of distinct steps from the index */
    /* the list is in ascending order */
    CODES_CHECK(codes_index_get_long(index, "step", steps, &stepSize), 0);
    printf("stepSize=%ld\n", (long)stepSize);
    for (i = 0; i < stepSize; i++)
        printf("%ld ", steps[i]);
    printf("\n");

    /*same as for "step"*/
    CODES_CHECK(codes_index_get_size(index, "level", &levelSize), 0);
    levels = (long*)malloc(sizeof(long) * levelSize);
    if (!levels) exit(1);

    /*same as for "step"*/
    CODES_CHECK(codes_index_get_long(index, "level", levels, &levelSize), 0);
    printf("levelSize=%ld\n", (long)levelSize);
    for (i = 0; i < levelSize; i++)
        printf("%ld ", levels[i]);
    printf("\n");

    /*same as for "step"*/
    // std::cout << "This is before getting to number size" << std::endl;
    // CODES_CHECK(codes_index_get_size(index, "number", &numberSize), 0);
    // numbers = (long*)malloc(sizeof(long) * numberSize);
    // if (!numbers) exit(1);

    // std::cout << "The size of the numbers: " << numberSize << std::endl;
    // /*same as for "step"*/

    // CODES_CHECK(codes_index_get_long(index, "number", numbers, &numberSize), 0);

    // std::cout << "The numbers themselves have been indexed and they are: " << std::endl;
    // printf("numberSize=%ld\n", (long)numberSize);
    // for (i = 0; i < numberSize; i++)
    //     printf("%ld ", numbers[i]);
    // printf("\n");

    /*same as for "step"*/
    CODES_CHECK(codes_index_get_size(index, "shortName", &shortNameSize), 0);
    shortName = (char**)malloc(sizeof(char*) * shortNameSize);
    if (!shortName) exit(1);
    /*same as for "step"*/
    CODES_CHECK(codes_index_get_string(index, "shortName", shortName, &shortNameSize), 0);
    printf("shortNameSize=%ld\n", (long)shortNameSize);
    for (i = 0; i < shortNameSize; i++)
        printf("%s ", shortName[i]);
    printf("\n");

    count = 0;
    /* nested loops on the keys values of the index */
    /* different order of the nested loops doesn't affect performance*/
    for (i = 0; i < shortNameSize; i++) {
        /* select the GRIB with shortName=shortName[i] */
        codes_index_select_string(index, "shortName", shortName[i]);

        for (l = 0; l < levelSize; l++) {
            /* select the GRIB with level=levels[l] */
            codes_index_select_long(index, "level", levels[l]);

            // for (j = 0; j < numberSize; j++) {
            //     /* select the GRIB with number=numbers[j] */
            //     codes_index_select_long(index, "number", numbers[j]);

            for (k = 0; k < stepSize; k++) {
                /* select the GRIB with step=steps[k] */
                codes_index_select_long(index, "step", steps[k]);

                /* create a new codes_handle from the index with the constraints
                    imposed by the select statements. It is a loop because
                    in the index there could be more than one GRIB with those
                    constraints */
                while ((h = codes_handle_new_from_index(index, &ret)) != NULL) {
                    count++;
                    if (ret) {
                        fprintf(stderr, "Error: %s\n", codes_get_error_message(ret));
                        exit(ret);
                    }
                    lenshortName = 200;
                    codes_get_string(h, "shortName", oshortName, &lenshortName);
                    codes_get_long(h, "level", &olevel);
                    // codes_get_long(h, "number", &onumber);
                    codes_get_long(h, "step", &ostep);
                    // printf("shortName=%s ", oshortName);
                    // printf("level=%ld ", olevel);
                    // // printf("number=%ld ", onumber);
                    // printf("step=%ld \n", ostep);

                    // for each element of the array
                        // if the shortnames match and the levels match
                            // store it in the paramIdxes array 
                            // print it out
                    for (int j=0; j<numParams; j++) {
                        long currLevel = passed_levels[j];
                        char currShortname[MAX_STRING_LENGTH] = shortName[j];
                        int result = strcmp(oshortName, currShortname);
                        if (result == 0 && currLevel == olevel) {
                            printf("\nShortname: %s was found at shortnameidx: %d\n", currShortname, i);
                            printf("and at levelIdx: %d\n", l);
                        }
                    }


                    codes_handle_delete(h);
                }
                if (ret && ret != GRIB_END_OF_INDEX) {
                    fprintf(stderr, "Error: %s\n", codes_get_error_message(ret));
                    exit(ret);
                }
            }
            
        }
    }
    printf("  %d messages selected\n", count);
}


