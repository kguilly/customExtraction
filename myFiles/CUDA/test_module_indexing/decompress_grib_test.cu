/*
This file will test if its possible to send a file pointer to CUDA and then extract the GRIB 2 file using 
an object generated by ECCODES that will indicate where to find the values 


*/



#include <iostream>
#include <stdlib.h>
#include "eccodes.h"
#include <cuda_runtime.h>
#include <vector>
#include <string>

// personal functions
#include "decompress_grib_test.h"
#include "shared_test_objs.h"

// station_t* orchestrate_grib_decompression(station_t* loc_st_arr, codes_index* grb_idx, FILE* f, int numStations, int numberOfPoints, 
//                                           int numSelectedParams){
    
    
//     // copy over all necessary information to the GPU

    
//     // remember to include space for the values array
//     //TODO: need to also pass the number of points so as to allocate for the lats,
//     // lons, and values arrays


//     // call the kernel

// }
// __global__ void cuda_decompress_grib(station_t* st_arr, codes_index* grb_idx, FILE* f, int numStations, int numberOfPoints) {
    
//     // find the idx
//     int id = blockIdx.x * blockDim.x + threadIdx.x;
//     int num_blocks = 5;
//     int num_threads = 256;
    
//     if (id < numberOfPoints) {
        
//         int err = 0;
//         const double missing = 1.0e36;
//         codes_handle * currHandle = NULL;
        
//         if ((currHandle = codes_handle_new_from_index(grb_idx, &err)) != NULL) {
//             // use the created handle to grab the data
//             double *grib_values, *grib_lats, *grib_lons;

//             CODES_CHECK(codes_grib_get_data(currHandle, grib_lats, grib_lons, grib_values), 0);

//             // call another kernel to handle matching the values to the correct station
//             match_station_to_values <<< num_blocks, num_threads >>> (st_arr, grib_values, numberOfPoints, numStations);
//         }

//     }

// }

// __global__ void match_station_to_values(station_t* st_arr, ) {

// }

station_t* extract_indexes(station_t * local_st_arr, double* lats, double* lons, int numStations, int numberOfPoints){

    int num_threads_to_use = 256;
    int num_blocks_to_use = 2;

    // make device copies of host params
    station_t* d_stationArr_findNearest;
    double* d_lats;
    double* d_lons;
    

    // allocate each of the arguments to the GPU
    if (cudaMalloc(&d_stationArr_findNearest, sizeof(station_t) * numStations) != cudaSuccess) {
        std::cout << "stationArr could not be allocated to GPU" << std::endl;
        return local_st_arr;
    }
    if (cudaMalloc(&d_lats, sizeof(double) * numberOfPoints) != cudaSuccess) {
        std::cout << "Grib lats could not be allocated to the GPU" << std::endl;
        cudaFree(d_stationArr_findNearest);
        return local_st_arr; 
    }
    if (cudaMalloc(&d_lons, sizeof(double) * numberOfPoints) != cudaSuccess) {
        std::cout << "Grib lons could not be allocated to the GPU" << std::endl;
        cudaFree(d_stationArr_findNearest);
        cudaFree(d_lats);
        return local_st_arr;
    }

    // copy each of the arguments over to the gpu
    if (cudaMemcpy(d_stationArr_findNearest, local_st_arr, sizeof(station_t) * numStations, cudaMemcpyHostToDevice) != cudaSuccess) {
        std::cout << "The stationArr could not be copied to the GPU" << std::endl;
        cudaFree(d_stationArr_findNearest);
        cudaFree(d_lats);
        cudaFree(d_lons);
        return local_st_arr;
    }
    if (cudaMemcpy(d_lats, lats, sizeof(double) * numberOfPoints, cudaMemcpyHostToDevice) != cudaSuccess) {
        std::cout << "The grib lats could not be copied to the GPU" << std::endl;
        cudaFree(d_stationArr_findNearest);
        cudaFree(d_lats);
        cudaFree(d_lons);
        return local_st_arr;
    }
    if (cudaMemcpy(d_lons, lons, sizeof(double) * numberOfPoints, cudaMemcpyHostToDevice) != cudaSuccess) {
        std::cout << "The grib lons could not be copied to the GPU" << std::endl;
        cudaFree(d_stationArr_findNearest);
        cudaFree(d_lats);
        cudaFree(d_lons);
        return local_st_arr;
    }
    
    // call the kernel
    cuda_find_nearest <<< num_blocks_to_use, num_threads_to_use >>> (d_stationArr_findNearest, d_lats, d_lons, numStations, numberOfPoints);
    // wait for em all to finish
    cudaDeviceSynchronize();

    // copy the elements from the GPU back over to the host
    if (cudaMemcpy(local_st_arr, d_stationArr_findNearest, sizeof(station_t) * numStations, cudaMemcpyDeviceToHost) != cudaSuccess) {
        std::cout << "cuda FAILED" << std::endl;
        cudaFree(d_stationArr_findNearest);
        cudaFree(d_lats);
        cudaFree(d_lons);
        return local_st_arr;
    }
    std::cout << "cuda success" << std::endl;
    // release
    cudaFree(d_stationArr_findNearest);
    cudaFree(d_lats);
    cudaFree(d_lons);

    return local_st_arr;
}

__global__ void cuda_find_nearest(station_t * d_stationArr, double * d_lats, double * d_lons, int numStations, int num_points) {
    int id = blockIdx.x * blockDim.x + threadIdx.x;

    if (id < numStations) {
        double min_distance = 999;
        int min_index = -1;
        
        station_t * curr_station = &d_stationArr[id];
        double st_lat = curr_station->lat;
        double st_lon = curr_station->lon;

        for (int i=0; i<num_points; i++) {
            double lat = d_lats[i];
            double lon = d_lons[i]; 
            double distance = sqrt(pow((st_lat - lat), 2) + pow((st_lon - lon), 2));

            if (distance < min_distance) {
                min_distance = distance;
                min_index = i;
            }
        }
        curr_station->closestPoint = min_index;
    }
}




