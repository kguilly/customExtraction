/*
This file will test if its possible to send a file pointer to CUDA and then extract the GRIB 2 file using 
an object generated by ECCODES that will indicate where to find the values 


*/



#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include "eccodes.h"
#include <cuda_runtime.h>
#include <vector>
#include <string>

// personal functions
#include "decompress_grib_test.h"
#include "shared_test_objs.h"

station_t* orchestrate_grib_decompression(station_t* loc_st_arr, FILE* f, int numStations, int numTotalParams, 
                                          long num_grib_points, bool* blnParamArr, size_t handle_size){
    
    // get the size of the file* obj
    fseek(f, 0, SEEK_END);
    long file_size = ftell(f);
    fseek(f, 0, SEEK_SET);

    int num_threads = 256;
    int num_blocks = 16;

    // copy over all necessary information to the GPU
    station_t* d_st_arr;
    FILE* d_file;
    double* d_lats, *d_lons, *d_values;
    codes_handle * d_handle; 
    bool* d_blnParamArr;   

    // allocate space to the device
    if (cudaMalloc(&d_lats, sizeof(double) * num_grib_points) != cudaSuccess) {
        std::cout << "Lats could not be allocated to the GPU" << std::endl;
        return loc_st_arr;
    }
    if (cudaMalloc(&d_lons, sizeof(double) * num_grib_points) != cudaSuccess) {
        std::cout << "Lons could not be allocated to the GPU" << std::endl;
        cudaFree(d_lats);
        return loc_st_arr;
    }
    if (cudaMalloc(&d_values, sizeof(double) * num_grib_points) != cudaSuccess) {
        std::cout << "Values could not be allocated to the GPU" << std::endl;
        cudaFree(d_lons);
        cudaFree(d_lats);
        return loc_st_arr;
    }
    if (cudaMalloc(&d_file, file_size * sizeof(FILE)) != cudaSuccess) {
        std::cout << "File could not be allocated to the GPU" << std::endl;
        cudaFree(d_lons);
        cudaFree(d_lats);
        cudaFree(d_values);
        return loc_st_arr;
    }
    if (cudaMalloc(&d_st_arr, numStations * sizeof(station_t)) != cudaSuccess) {
        std::cout << "StationArr could not be allocated to the GPU" << std::endl;
        cudaFree(d_lons);
        cudaFree(d_lats);
        cudaFree(d_values);
        cudaFree(d_file);
        return loc_st_arr;
    }
    // TODO: fix allocation
    if (cudaMalloc(&d_handle, handle_size) != cudaSuccess) {
        std::cout << "Handle could not be allocated to the GPU" << std::endl;
        cudaFree(d_lons);
        cudaFree(d_lats);
        cudaFree(d_values);
        cudaFree(d_file);
        cudaFree(d_st_arr);
        return loc_st_arr;
    }
    if (cudaMalloc(&d_blnParamArr, sizeof(bool) * numTotalParams) != cudaSuccess) {
        std::cout << "BlnParamArr could not be allocated to the GPU" << std::endl;
        cudaFree(d_lons);
        cudaFree(d_lats);
        cudaFree(d_values);
        cudaFree(d_file);
        cudaFree(d_st_arr);
        cudaFree(d_handle);
        return loc_st_arr;
    }

    // space has been allocated, now copy over
    if (cudaMemcpy(d_st_arr, loc_st_arr, sizeof(station_t) * numStations, cudaMemcpyHostToDevice) != cudaSuccess) {
        std::cout << "The stationArr could not be copied to the GPU" << std::endl;
        cudaFree(d_lons);
        cudaFree(d_lats);
        cudaFree(d_values);
        cudaFree(d_file);
        cudaFree(d_handle);
        cudaFree(d_blnParamArr);
        return loc_st_arr;
    }
    if (cudaMemcpy(d_file, f, sizeof(FILE) * file_size, cudaMemcpyHostToDevice) != cudaSuccess) {
        std::cout << "The file could not be copied to the GPU" << std::endl;
        cudaFree(d_lons);
        cudaFree(d_lats);
        cudaFree(d_values);
        cudaFree(d_file);
        cudaFree(d_handle);
        cudaFree(d_blnParamArr);
        return loc_st_arr;
    }
    if (cudaMemcpy(d_blnParamArr, blnParamArr, sizeof(bool) * numTotalParams, cudaMemcpyHostToDevice) != cudaSuccess) {
        std::cout << "The paramArr could not be copied to the GPU" << std::endl;
        cudaFree(d_lons);
        cudaFree(d_lats);
        cudaFree(d_values);
        cudaFree(d_file);
        cudaFree(d_handle);
        cudaFree(d_blnParamArr);
        return loc_st_arr;
    }

    // call the kernel
    cuda_decompress_grib <<< num_blocks, num_threads >>> (d_st_arr, d_file, d_lats, d_lons,\
                                                          d_values, d_handle, numStations, \
                                                          num_grib_points, d_blnParamArr, numTotalParams);
    cudaDeviceSynchronize();


    // copy over the d_st_arr to the local station array and return it
    if (cudaMemcpy(loc_st_arr, d_st_arr, sizeof(station_t) * numStations, cudaMemcpyDeviceToHost) != cudaSuccess) {
        std::cout << "cuda FAILED" << std::endl;
        cudaFree(d_lons);
        cudaFree(d_lats);
        cudaFree(d_values);
        cudaFree(d_file);
        cudaFree(d_handle);
        cudaFree(d_blnParamArr);    
        return loc_st_arr;
    }

    // free all objects used in the kernel
    cudaFree(d_lons);
    cudaFree(d_lats);
    cudaFree(d_values);
    cudaFree(d_file);
    cudaFree(d_handle);
    cudaFree(d_blnParamArr);

}

__global__ void cuda_decompress_grib(station_t* st_arr, FILE* f, double* d_lats, double* d_lons,
                                     double* d_values, codes_handle* d_handle, int numStations, 
                                     long num_grib_points, bool* d_blnParamArr, int numTotalParams) {
    
    // find the idx
    int id = blockIdx.x * blockDim.x + threadIdx.x;
    
    if (id < numTotalParams) {
        int err = 0, msg_count = 0;
        const double missing = 1.2345e20;

        // decompress the file, looping through the handle object
        while((d_handle = codes_handle_new_from_file(0, f, PRODUCT_GRIB, &err))) {
            msg_count++;

            // if this idx of the blnParamarr is true, decompress the information
            if (d_blnParamArr[msg_count] == true) {
                CODES_CHECK(codes_get_long(d_handle, "numberOfPoints", &num_grib_points), 0);
                CODES_CHECK(codes_set_double(d_handle, "missingValue", missing), 0);
                CODES_CHECK(codes_grib_get_data(d_handle, d_lats, d_lons, d_values), 0);

                // call another kernel to match d_values to the station array
                match_station_values(st_arr, d_values, msg_count, numStations);

            }
        }
    }
}

__device__ void match_station_values(station_t* st_arr, double* gr_vals, int msg_count, int numStations) {
    // find the idx
    int id = blockIdx.x * blockDim.x + threadIdx.x;
    int val_idx = msg_count - 1;

    if (id < numStations) {
        station_t * this_st = &st_arr[id];
        this_st->values[0][val_idx] = gr_vals[this_st->closestPoint];
    }
}

station_t* extract_indexes(station_t * local_st_arr, double* lats, double* lons, int numStations, int numberOfPoints){

   int num_threads_to_use = 256;
    int num_blocks_to_use = 2;

    // make device copies of host params
    station_t* d_stationArr_findNearest;
    double* d_lats;
    double* d_lons;
    

    // allocate each of the arguments to the GPU
    if (cudaMalloc(&d_stationArr_findNearest, sizeof(station_t) * numStations) != cudaSuccess) {
        std::cout << "stationArr could not be allocated to GPU" << std::endl;
        return local_st_arr;
    }
    if (cudaMalloc(&d_lats, sizeof(double) * numberOfPoints) != cudaSuccess) {
        std::cout << "Grib lats could not be allocated to the GPU" << std::endl;
        cudaFree(d_stationArr_findNearest);
        return local_st_arr; 
    }
    if (cudaMalloc(&d_lons, sizeof(double) * numberOfPoints) != cudaSuccess) {
        std::cout << "Grib lons could not be allocated to the GPU" << std::endl;
        cudaFree(d_stationArr_findNearest);
        cudaFree(d_lats);
        return local_st_arr;
    }

    // copy each of the arguments over to the gpu
    if (cudaMemcpy(d_stationArr_findNearest, local_st_arr, sizeof(station_t) * numStations, cudaMemcpyHostToDevice) != cudaSuccess) {
        std::cout << "The stationArr could not be copied to the GPU" << std::endl;
        cudaFree(d_stationArr_findNearest);
        cudaFree(d_lats);
        cudaFree(d_lons);
        return local_st_arr;
    }
    if (cudaMemcpy(d_lats, lats, sizeof(double) * numberOfPoints, cudaMemcpyHostToDevice) != cudaSuccess) {
        std::cout << "The grib lats could not be copied to the GPU" << std::endl;
        cudaFree(d_stationArr_findNearest);
        cudaFree(d_lats);
        cudaFree(d_lons);
        return local_st_arr;
    }
    if (cudaMemcpy(d_lons, lons, sizeof(double) * numberOfPoints, cudaMemcpyHostToDevice) != cudaSuccess) {
        std::cout << "The grib lons could not be copied to the GPU" << std::endl;
        cudaFree(d_stationArr_findNearest);
        cudaFree(d_lats);
        cudaFree(d_lons);
        return local_st_arr;
    }
    
    // call the kernel
    cuda_find_nearest <<< num_blocks_to_use, num_threads_to_use >>> (d_stationArr_findNearest, d_lats, d_lons, numStations, numberOfPoints);
    // wait for em all to finish
    cudaDeviceSynchronize();

    // copy the elements from the GPU back over to the host
    if (cudaMemcpy(local_st_arr, d_stationArr_findNearest, sizeof(station_t) * numStations, cudaMemcpyDeviceToHost) != cudaSuccess) {
        std::cout << "cuda FAILED" << std::endl;
        cudaFree(d_stationArr_findNearest);
        cudaFree(d_lats);
        cudaFree(d_lons);
        return local_st_arr;
    }
    std::cout << "cuda success" << std::endl;
    // release
    cudaFree(d_stationArr_findNearest);
    cudaFree(d_lats);
    cudaFree(d_lons);

    return local_st_arr;
}

__global__ void cuda_find_nearest(station_t * d_stationArr, double * d_lats, double * d_lons, int numStations, int num_points) {
    int id = blockIdx.x * blockDim.x + threadIdx.x;

    if (id < numStations) {
        double min_distance = 999;
        int min_index = -1;
        
        station_t * curr_station = &d_stationArr[id];
        double st_lat = curr_station->lat;
        double st_lon = curr_station->lon;

        for (int i=0; i<num_points; i++) {
            double lat = d_lats[i];
            double lon = d_lons[i]; 
            double distance = sqrt(pow((st_lat - lat), 2) + pow((st_lon - lon), 2));

            if (distance < min_distance) {
                min_distance = distance;
                min_index = i;
            }
        }
        curr_station->closestPoint = min_index;
    }
}




